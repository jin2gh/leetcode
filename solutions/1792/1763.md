## [最长的美好子字符串](https://leetcode-cn.com/problems/longest-nice-substring/)
### 题解
+ [TS](../../ts/1792/1763.ts)

#### 分治
**思路**
1. 用 `lower` 和 `upper` 统计大小写字符的出现情况，如果 `lower = upper`，说明当前的字符串是美好字符串；
2. 否则将字符串根据只有大写或小写的字符分割成不用的子串，再比较子串，如果符合条件，与存储的符合条件的子串比较长度并替换。


**复杂度分析**
+ 时间复杂度：O(n * |S|)，n 为字符串的长度，|S| 为字符集的大小，|S| = 52，最多只有 26 个不同的英文字母，所以递归深度最多 `|S|/2` 。
+ 空间复杂度：O(|S|)，最坏情况下需要递归 |S| 次。