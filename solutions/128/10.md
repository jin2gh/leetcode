## [正则表达式匹配](https://leetcode.cn/problems/regular-expression-matching/)
### 题解
+ [TS](../../ts/128/10.ts)

#### 动态规划
**思路**
用 `f[i][j]` 表示 s 的前 i 个字符和 p 的前 j 个字符是否匹配。考虑 p 中第 j 个字符的情况：
+ 如果是一个小写字母，可以得到状态转移方程：
  - `s[i] == p[j]`，则 `f[i][j] = f[i-1][j-1]`
  - `s[i] != p[j]`，则 `f[i][j] = false`
+ 如果是一个 `*`，状态转移方程如下：
  - `s[i] == p[j - 1]`，则 `f[i][j] = f[i-1][j] || f[i][j-2]`
  - `s[i] != p[j - 1]`，则 `f[i][j] = f[i][j-2]`
+ 如果是一个 `.`，一定匹配
动态规划的边界 `f[0][0] = true`，结果为 `f[m][n]`，m、n 为 s 和 p 的长度。

**复杂度分析**
+ 时间复杂度：O(m * n)，m、n 为 s 和 p 的长度。
+ 空间复杂度：O(m * n)，m、n 为 s 和 p 的长度。