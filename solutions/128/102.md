## [二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/)
### 题解
+ [TS](../../ts/128/102.ts)

#### BFS
**思路**
借助队列来实现，将当前节点出队后，判断是否有左右子节点，如果有将左右子节点放入队列。

**复杂度分析**
+ 时间复杂度：O(n) 或 O(n²)，需要看语言实现的 `shift` 的复杂度：如果是 O(1)，总时间复杂度为 O(n)；如果是 O(n)，总时间复杂度是 O(n²)。
+ 空间复杂度：O(n)，队列中的元素不会超过 n 个。

#### DFS
**思路**
+ 用 index 表示层级，nodes 为节点结果数组；
+ 遍历 root，将节点 node 当前的值加入对应层级的数组中，然后判断节点 node 是否有子节点，有则继续递归

**复杂度分析**
+ 时间复杂度：O(n)，n 为树的节点数。
+ 空间复杂度：O(n)，最坏情况下，链式节点，递归深度占用 O(n) 空间。